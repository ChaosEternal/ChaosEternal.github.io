<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"https://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="https://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<link rel="alternate"
      type="appliation/rss+xml"
      href="http://chaoseternal.net/rss.xml"
      title="RSS feed for http://chaoseternal.net/">
<title>Twisted Space and Time</title><meta  name="author" content="Jun Sheng" />
<link href='http://fonts.googleapis.com/css?family=Roboto&subset=latin' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Ubuntu+Mono' rel='stylesheet' type='text/css'>
<link href= "static/style.css" rel="stylesheet" type="text/css" />
<link rel="icon" href="static/favicon.ico">
<link rel="apple-touch-icon-precomposed" href="static/favicon-152.png">
<link rel="msapplication-TitleImage" href="static/favicon-144.png">
<link rel="msapplication-TitleColor" href="#0141ff">
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"> </script>
<meta http-equiv="content-type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1"></head>
<body>
<div id="preamble" class="status"><div class="header">
  <a href="http://chaoseternal.net">Chaos Eternal</a>
  <div class="sitelinks">
    <a href="https://twitter.com/chaoseternal">Twitter</a> | <a href="http://github.com/Chaoseternal">Github</a>
  </div>
</div></div>
<div id="content"><div class="post-date">29 Oct 2017</div><h1 class="post-title"><a href="http://chaoseternal.net/syntax-scheme.html">Scheme Syntax-Case usage</a></h1>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Macros of The Scheme Programming Language</h2>
<div class="outline-text-2" id="text-1">
<p>
Scheme has a powerful macro system, in most scheme implementation, only very limited primitive forms
are implemented and others are derived by using macros. For example, r5rs standard defines 23 syntactic constructs, 11 of them can be defined using other more fundamental ones. <sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>
</p>

<p>
There are many macro systems exist in Scheme's world, <code>define-macro</code>, <code>syntax-rules</code>, <code>syntax-case</code> are commonly adopted.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">The <code>define-macro</code> system</h2>
<div class="outline-text-2" id="text-2">
<p>
  <code>define-macro</code> AKA <code>defmacro</code> is the traditional way of defining macro in lisp world. Macros defined by <code>define-macro</code> are roughly procedures transform(expand) input form to another s-expression, 
the transformation itself usually be called "applying the macro". Generally speaking, the body of <code>define-macro</code> can be any expression which returns a valid scheme expression on evaluation, 
and the arguments of <code>define-macro</code> are also the arguments of the expression(if seen as body of a lambda).
</p>

<p>
For example, this macro:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #1e7bda; font-weight: bold;">define-macro</span> (<span style="color: #1e7bda; font-weight: bold;">when</span> cond exp . rest)
  `(<span style="color: #1e7bda; font-weight: bold;">if</span> ,cond
       (<span style="color: #1e7bda; font-weight: bold;">begin</span> ,exp . ,rest)))
</pre>
</div>
<p>
will define a macro named <code>when</code>.
And on applying this macro, such form <code>(when (&gt; n 0) exp1 exp2)</code> will be transformed (expanded) as:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #1e7bda; font-weight: bold;">if</span> (&gt; n 0)
    (<span style="color: #1e7bda; font-weight: bold;">begin</span> exp1 
           exp2))
</pre>
</div>
<p>
This transformation done by macro <code>when</code> is just filling out a template using parameters of <code>when</code>: <code>(&gt; n 0)</code>, <code>exp1</code> and <code>(exp2)</code>. Or say, the macro generates new codes.
</p>

<p>
Because the nature of macros, code generation, macros are very powerful tools in lisp languages as well as in Scheme.
</p>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Hygienic problem of <code>define-macro</code></h2>
<div class="outline-text-2" id="text-3">
<p>
  The <code>define-macro</code> macro system is so rough that it does not capture binding of any symbols appeared in macro definition, and these symbols' meaning can be changed when the macros applying,
this will make the macros' behavior be very wierd if they are used with careless.
</p>

<p>
Consider the macro <code>when</code> defined in the previous secrtion, in the scenario demostraded here: 
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #1e7bda; font-weight: bold;">let</span> ((<span style="color: #1e7bda; font-weight: bold;">begin</span> list))
  (<span style="color: #1e7bda; font-weight: bold;">when</span> #f 1 2))
</pre>
</div>
<p>
the code will be equivalent of:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #1e7bda; font-weight: bold;">if</span> #t
    (list 1 2))
</pre>
</div>
<p>
This is because the <code>define-macro</code> only defines the form that <code>when</code> will be expanded but not the binding of symbols, these symbols' meaning can be altered in different context.
</p>

<p>
Such problem is called the hygienic problem.
</p>

<p>
Scheme implatations which have <code>define-macro</code> system also provide <code>gensym</code> or similar procedures which can generate symbols on the fly to mimic(partially) the hygienic problem of the <code>define-macro</code> system.
For example, this code defined a naive macro <code>swap!</code> which swaps value of two variables:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #1e7bda; font-weight: bold;">define-macro</span> (<span style="color: #959508;">swap!</span> o1 o2)
  `(<span style="color: #1e7bda; font-weight: bold;">let</span> ((tmp ,o1))
     (<span style="color: #1e7bda; font-weight: bold;">set!</span> ,o1 ,o2)
     (<span style="color: #1e7bda; font-weight: bold;">set!</span> ,o2 tmp)))
</pre>
</div>
<p>
If one uses this marco like <code>(swap! tmp something)</code> or <code>(swap! something tmp)</code>, the symbol <code>tmp</code> will be captured and the result is incorrect.
This macro can be rewritten using <code>gensym</code>:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #1e7bda; font-weight: bold;">define-macro</span> (<span style="color: #959508;">swap1</span> o1 o2)
  (<span style="color: #1e7bda; font-weight: bold;">let</span> ((tmp (gensym)))
    `(<span style="color: #1e7bda; font-weight: bold;">let</span> ((,tmp ,o1))
       (<span style="color: #1e7bda; font-weight: bold;">set!</span> ,o1 ,o2)
       (<span style="color: #1e7bda; font-weight: bold;">set!</span> ,o2 ,tmp))))
</pre>
</div>
<p>
In this version of <code>swap!</code>, the danger of unwanted symbol capture will not exist.
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">The <code>syntax-rules</code> system</h2>
<div class="outline-text-2" id="text-4">
<p>
<code>syntax-rules</code> is a solution to hygienic problems. Since it is adopted in the R5RS, it is wildly implemented in different Scheme implementations.
<code>syntax-rules</code> uses pattern matching to construct macros.
</p>

<p>
With <code>syntax-rules</code>, the macro <code>when</code> can be re-written as:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #1e7bda; font-weight: bold;">define-syntax</span> <span style="color: #959508;">when</span>
  (<span style="color: #1e7bda; font-weight: bold;">syntax-rules</span> ()
    ((<span style="color: #1e7bda; font-weight: bold;">when</span> cond exp1 ...)
     (<span style="color: #1e7bda; font-weight: bold;">if</span> cond
         (<span style="color: #1e7bda; font-weight: bold;">begin</span> exp1 ...)))))
</pre>
</div>

<p>
The syntax of using <code>syntax-rules</code> is <code>(syntax-rules literals (pattern template) ...)</code>, the macro will replace evey matching pattern to the corresponding template.
</p>

<p>
  The major difference between syntax-rules and define-marco is that <code>syntax-rules</code> garentees hygienicness, in fact, all symbols occure in <code>template</code> has definite meaning: if the symbol is matched in pattern, 
the pattern value is captured, else the binding of symbols in the environment is captured. Thus these symbols' meaning remains the same wherever they are used, this is hygienicness of macro.
</p>

<p>
<code>syntax-rules</code> is very useful, but it also has limitations<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup><sup>, </sup><sup><a id="fnr.3" name="fnr.3" class="footref" href="#fn.3">3</a></sup>, it does not provides ways to modify the templates, there exists some cases where it is harder to write with <code>syntax-rules</code> than define-macro.
For more details about <code>syntax-rules</code> system, this article<sup><a id="fnr.4" name="fnr.4" class="footref" href="#fn.4">4</a></sup> is very useful.
</p>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">The <code>syntax-case</code> system</h2>
<div class="outline-text-2" id="text-5">
<p>
The <code>syntax-case</code> system is somehow similar to <code>gensym</code> approach, but it is an extreme. It has the same power as <code>define-macro</code> but retains hygenicness.
Using <code>syntax-case</code>, the macro <code>when</code> can be rewritten as:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #1e7bda; font-weight: bold;">define-syntax</span> <span style="color: #959508;">when</span>
  (<span style="color: #1e7bda; font-weight: bold;">lambda</span> (stx)
    (<span style="color: #1e7bda; font-weight: bold;">syntax-case</span> stx ()
        ((_ cond exp1 . exp2)
         #'(<span style="color: #1e7bda; font-weight: bold;">if</span> cond
               (<span style="color: #1e7bda; font-weight: bold;">begin</span> exp1 . exp2))))))
</pre>
</div>
<p>
  Here, the form <code>#'(if cond (begin exp1 . exp2))</code> is the corresponding part of <code>`(if ,cond (begin ,exp . ,rest))</code> of <code>define-macro</code>, they have similar structure. The difference
here is only that the body of syntax-case should return a syntax object, not a mere list as define-macro returns. But in <code>syntax-case</code>, symbol <code>if</code> and <code>begin</code> was captured the definition of defining environment while <code>cond</code>, <code>exp1</code> and <code>exp2</code> are replaced with applying 
arguments when the macro is applied, since they appear in the pattern form of <code>syntax-case</code>. This is how hygenicness is archieved.
</p>

<p>
The macro <code>swap!</code>:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #1e7bda; font-weight: bold;">define-syntax</span> <span style="color: #959508;">swap!</span>
  (<span style="color: #1e7bda; font-weight: bold;">lambda</span> (stx)
    (<span style="color: #1e7bda; font-weight: bold;">syntax-case</span> stx ()
      ((_ op1 op2)
       #'(<span style="color: #1e7bda; font-weight: bold;">let</span> ((tmp op1))
           (<span style="color: #1e7bda; font-weight: bold;">set!</span> op1 op2)
           (<span style="color: #1e7bda; font-weight: bold;">set!</span> op2 tmp))))))
</pre>
</div>
<p>
The expanded result(using 'expand' of ChezScheme <code>(expand '(swap! var1 var2))</code>):
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #1e7bda; font-weight: bold;">let</span> ([#{tmp cvbrbh0gnpwjvy0dl1m1nb-1} var1])
  (<span style="color: #1e7bda; font-weight: bold;">set!</span> var1 var2)
  (<span style="color: #1e7bda; font-weight: bold;">set!</span> var2 #{tmp cvbrbh0gnpwjvy0dl1m1nb-1}))
</pre>
</div>
<p>
It is shown that hygenicness is automatically done by the same way of <code>gensym</code>.
</p>

<p>
  The 'syntax' objects is a special type objects defined in scheme implementations which has syntax-case system ported. They can be converted to scheme objects on demand, and when returned by syntax-case, 
the macro expansion is done.
</p>

<p>
The following examples shows a more complex usage of syntax-case, upon expansion, the macro will be expanded to n-th fibonacci number:
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #319448;">;; </span><span style="color: #319448;">this macro using iterative approach</span>
(<span style="color: #1e7bda; font-weight: bold;">define-syntax</span> <span style="color: #959508;">fib</span>
  (<span style="color: #1e7bda; font-weight: bold;">lambda</span> (x)
    (<span style="color: #1e7bda; font-weight: bold;">syntax-case</span> x ()
      ((fib n)
       #'(fib n 1 0))
      ((fib 0 num2 num3) (syntax-&gt;datum #'num2))
      ((fib num1 num2 num3)
       (with-syntax ((n (datum-&gt;syntax #'fib
                                       (- (syntax-&gt;datum #'num1)
                                          1)))
                     (n2 (datum-&gt;syntax #'fib
                                        (+ (syntax-&gt;datum #'num2)
                                           (syntax-&gt;datum #'num3))))
                     (n3 (<span style="color: #1e7bda; font-weight: bold;">syntax</span> num2)))
         #'(fib n n2 n3))))))
<span style="color: #319448;">;; </span><span style="color: #319448;">this macro is recursive and much slower</span>
(<span style="color: #1e7bda; font-weight: bold;">define-syntax</span> <span style="color: #959508;">fib2</span>
  (<span style="color: #1e7bda; font-weight: bold;">lambda</span> (x)
    (<span style="color: #1e7bda; font-weight: bold;">syntax-case</span> x ()
      ((fib2 0)
       #'1)
      ((fib2 1)
       #'1)
      ((fib2 n)
       (with-syntax ((n2 (datum-&gt;syntax #'fib2
                                        (- (syntax-&gt;datum #'n) 1)))
                     (n3 (datum-&gt;syntax #'fib2
                                        (- (syntax-&gt;datum #'n) 2))))
         #'(+ (fib2 n2) (fib2 n3)))))))
</pre>
</div>

<p>
The <code>syntax-case</code> system is so powerful that even the <code>syntax-rules</code> system is just a derivation of it<sup><a id="fnr.5" name="fnr.5" class="footref" href="#fn.5">5</a></sup>. 
</p>

<p>
In rencent Elixr<sup><a id="fnr.6" name="fnr.6" class="footref" href="#fn.6">6</a></sup> release(1.2), a ~with~<sup><a id="fnr.7" name="fnr.7" class="footref" href="#fn.7">7</a></sup> clause is introduced to provide guarded execution of some code, the same effect can be easily archieved in scheme by using macros:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #1e7bda; font-weight: bold;">define-syntax</span> <span style="color: #959508;">and-let*-values-check</span>
  (<span style="color: #1e7bda; font-weight: bold;">lambda</span> (stx)
    (<span style="color: #1e7bda; font-weight: bold;">syntax-case</span> stx (<span style="color: #1e7bda; font-weight: bold;">else</span>)
      ((kw (?bind0 ?bind1 ...) ?body0 ... (<span style="color: #1e7bda; font-weight: bold;">else</span> ?expr0 ...))
       (<span style="color: #1e7bda; font-weight: bold;">syntax-case</span> #'?bind0 ()
         (((?b0 ?b1 ...) ?exp)
          (<span style="color: #1e7bda; font-weight: bold;">let*</span> ((?check-b0 (car (generate-temporaries (list #'?b0)))))
            #`(<span style="color: #1e7bda; font-weight: bold;">let-values</span> (((#,?check-b0 ?b1 ...) ?exp))
                (<span style="color: #1e7bda; font-weight: bold;">if</span> (equal? #,?check-b0 ?b0)
                    (kw (?bind1 ...) ?body0 ...)
                    (<span style="color: #1e7bda; font-weight: bold;">begin</span> ?expr0 ...)))))))
      ((_ () ?body0 ... (<span style="color: #1e7bda; font-weight: bold;">else</span> ?expr0 ...))
       #'(<span style="color: #1e7bda; font-weight: bold;">begin</span> ?body0 ...))
      ((kw (?bind0 ...) ?body0 ...)
       #'(kw (?bind0 ...) ?body0 ... (<span style="color: #1e7bda; font-weight: bold;">else</span> #f))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Conclusions and more</h2>
<div class="outline-text-2" id="text-6">
<p>
  In scheme's world, the word 'syntax' mostly refers to two things, one is the lexical structure of program, which defined by the reader, 
usually they are s-expressions or converted to s-expressions by reader, other one is the context structure of a program, which defines how program is executed.
Due to the powerfulness of s-expressions, the first meaning of syntax is insignificant compare to the second one. And with the macro system, one can easily extend the
 syntax scheme, just as shown in <sup><a id="fnr.5.100" name="fnr.5.100" class="footref" href="#fn.5">5</a></sup>. The lastest example of previous section even shows how to borrow syntax-sugars from other languages. Yes, syntax-sugar, as its name, 
they are not essentials but sugars just make life happier. And even type systems can be defined using macros<sup><a id="fnr.8" name="fnr.8" class="footref" href="#fn.8">8</a></sup>.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
<a href="https://en.wikipedia.org/wiki/Scheme_(programming_language)">https://en.wikipedia.org/wiki/Scheme_(programming_language)</a>#Minimalism
</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
<a href="https://groups.google.com/forum/#!msg/comp.lang.scheme/gKdyiCnf54E/sxo_gYLvWuUJ;context-place=msg/comp.lang.scheme/Alkectj2ge0/N65W9KNd6LcJ">https://groups.google.com/forum/#!msg/comp.lang.scheme/gKdyiCnf54E/sxo_gYLvWuUJ;context-place=msg/comp.lang.scheme/Alkectj2ge0/N65W9KNd6LcJ</a>
</p></div>

<div class="footdef"><sup><a id="fn.3" name="fn.3" class="footnum" href="#fnr.3">3</a></sup> <p class="footpara">
<a href="https://www.gnu.org/software/guile/manual/html_node/Syntax-Rules.html">https://www.gnu.org/software/guile/manual/html_node/Syntax-Rules.html</a>
</p></div>

<div class="footdef"><sup><a id="fn.4" name="fn.4" class="footnum" href="#fnr.4">4</a></sup> <p class="footpara">
<a href="https://hipster.home.xs4all.nl/lib/scheme/gauche/define-syntax-primer.txt">https://hipster.home.xs4all.nl/lib/scheme/gauche/define-syntax-primer.txt</a>
</p></div>

<div class="footdef"><sup><a id="fn.5" name="fn.5" class="footnum" href="#fnr.5">5</a></sup> <p class="footpara">
<a href="http://www.cs.indiana.edu/~dyb/pubs/tr356.pdf">http://www.cs.indiana.edu/~dyb/pubs/tr356.pdf</a>
</p></div>

<div class="footdef"><sup><a id="fn.6" name="fn.6" class="footnum" href="#fnr.6">6</a></sup> <p class="footpara">
<a href="https://elixir-lang.github.io">https://elixir-lang.github.io</a>
</p></div>

<div class="footdef"><sup><a id="fn.7" name="fn.7" class="footnum" href="#fnr.7">7</a></sup> <p class="footpara">
<a href="http://learningelixir.joekain.com/learning-elixir-with/">http://learningelixir.joekain.com/learning-elixir-with/</a>
</p></div>

<div class="footdef"><sup><a id="fn.8" name="fn.8" class="footnum" href="#fnr.8">8</a></sup> <p class="footpara">
<a href="http://www.ccs.neu.edu/home/stchang/popl2017/">http://www.ccs.neu.edu/home/stchang/popl2017/</a>
</p></div>


</div>
</div><div class="post-date">29 Oct 2017</div><h1 class="post-title"><a href="http://chaoseternal.net/packrat-intro.html">Packrat parser in R6RS</a></h1>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Packrat algorithm</h2>
<div class="outline-text-2" id="text-1">
<p>
Packrat parsing algorithm is an algorithm for parsing PEG<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>, it can parse PEG in guaranteed linear time.<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup>
There are lots of resources about PEG and packrat algorithm here: <a href="http://bford.info/packrat/">http://bford.info/packrat/</a>.
<a href="https://tech.labs.oliverwyman.com/author/tonyg/">Tony Garnock-Jones</a> had an implementation of packrat in his <a href="http://tech.labs.oliverwyman.com/blog/2005/08/11/extensible-parsing-systems/">blog</a>, and he then <a href="https://tech.labs.oliverwyman.com/blog/2005/08/22/json-for-mzscheme-and-a-portable-packrat-parsing-combinator-library/">rewrote</a> it using MzScheme and then upon the parser he wrote a JSON read-write library. 
He also wrote a <a href="http://tech.labs.oliverwyman.com/downloads/dev.lshift.net/tonyg/packrat.pdf">document</a> about how to use it.
This packrat library is included in Chicken Scheme's egg system<sup><a id="fnr.3" name="fnr.3" class="footref" href="#fn.3">3</a></sup> and then be ported as a R7RS library<sup><a id="fnr.4" name="fnr.4" class="footref" href="#fn.4">4</a></sup>. 
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">A brief walk through of packrat</h2>
<div class="outline-text-2" id="text-2">
<p>
PEG is very similar to regexp. Here is the comparison of concepts between PEG and regexp
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">&#xa0;</td>
<td class="left">PEG</td>
<td class="left">Regexp</td>
</tr>

<tr>
<td class="left">atoms</td>
<td class="left">any non-terminal symbol</td>
<td class="left">any character</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">terminal symbol</td>
<td class="left">$, \&gt;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">empty</td>
<td class="left">empty</td>
</tr>

<tr>
<td class="left">combination operators</td>
<td class="left">sequence</td>
<td class="left">string</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">ordered choice</td>
<td class="left">a &vert; b</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">zero-or-more</td>
<td class="left">a*</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">one-or-more</td>
<td class="left">a+</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">optional</td>
<td class="left">a?</td>
</tr>
</tbody>
</table>

<p>
Generally PEG is more powerful than regular expressions, for example, PEG can handle nested parenthesis while regexp can't, this is because PEG is recursive. 
For example, regular expressions can't process JSON data with arbitrary depth.
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">My Packrat extensions</h3>
<div class="outline-text-3" id="text-2-1">
<p>
I have written some extensions to original packrat library, these extensions is intended to make life easier with packrat. 
The code can be find here: <a href="https://github.com/ChaosEternal/packrat-extended"><a href="https://github.com/ChaosEternal/packrat-extended">https://github.com/ChaosEternal/packrat-extended</a></a>, tested under ChezScheme.
First, I add a <code>(? pred)</code> syntax, a place for a user defined predictors (in packrat.ss),
then I add some help functions like character test functions and logic combination functions (in packrat-utils.ss), some of them(token, json-string) are isolated from the json parser.
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Using Packrat</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Macro  <code>packrat-parser</code> provides syntactic sugar to build complex parser combinator from simpler ones. 
Input of these combinators are generators which are producing pairs of <code>(kind value)</code>, and parser will check with the kind and take the value.
Although the generator in the example specified in Tony's document generates ~'(kind value)~ where kind is symbol and value is numeric value, <code>(char char)</code> will be generated in most use case.
</p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Parse json step by step</h3>
<div class="outline-text-3" id="text-2-3">
</div><div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1">Very beginning</h4>
<div class="outline-text-4" id="text-2-3-1">
</div><ul class="org-ul"><li><a id="sec-2-3-1-1" name="sec-2-3-1-1"></a>Generator<br  /><div class="outline-text-5" id="text-2-3-1-1">
<p>
This generator read from a given port and produces a stream of (char . char).
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #1e7bda; font-weight: bold;">import</span> (ext packrat)
        (ext packrat-utils)
        (rnrs (6))
        )

(<span style="color: #1e7bda; font-weight: bold;">define</span> (<span style="color: #58b1f3;">generator</span> p)
  (<span style="color: #1e7bda; font-weight: bold;">let</span> ((ateof #f)
        (pos (top-parse-position <span style="color: #e96060;">"&lt;?&gt;"</span>)))
    (<span style="color: #1e7bda; font-weight: bold;">lambda</span> ()
      (<span style="color: #1e7bda; font-weight: bold;">if</span> ateof
          (values pos #f)
          (<span style="color: #1e7bda; font-weight: bold;">let</span> ((x (read-char p)))
            (<span style="color: #1e7bda; font-weight: bold;">if</span> (eof-object? x)
                (<span style="color: #1e7bda; font-weight: bold;">begin</span>
                  (<span style="color: #1e7bda; font-weight: bold;">set!</span> ateof #t)
                  (values pos (cons #\x04 #\x04)))
                (<span style="color: #1e7bda; font-weight: bold;">let</span> ((old-pos pos))
                  (<span style="color: #1e7bda; font-weight: bold;">set!</span> pos (update-parse-position pos x))
                  (values old-pos (cons x x)))))))))
</pre>
</div>
</div>
</li>
<li><a id="sec-2-3-1-2" name="sec-2-3-1-2"></a>Parser for Whitespace<br  /><div class="outline-text-5" id="text-2-3-1-2">
<p>
We can start from a very simple parser which just reads arbitary number of white-spaces.
The parse returns nothing but an <code>eof-object</code> when parse reaches the end of file.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">syntax</td>
</tr>

<tr>
<td class="left">any</td>
<td class="left">=</td>
<td class="left">white eof</td>
</tr>

<tr>
<td class="left">white</td>
<td class="left">=</td>
<td class="left">ws*</td>
</tr>
</tbody>
</table>

<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #1e7bda; font-weight: bold;">define</span> <span style="color: #58b1f3;">parser</span>
  (packrat-parser any
                  (any ((white '#\x04) (eof-object)))
                  (white (((? char-whitespace?) white) 'whitespace)
                         (() 'whitespace))))
</pre>
</div>
</div>
</li>

<li><a id="sec-2-3-1-3" name="sec-2-3-1-3"></a>A reader function<br  /><div class="outline-text-5" id="text-2-3-1-3">
<p>
A reader function integrates parser and generator.
</p>
<div class="org-src-container">

<pre class="src src-scheme">  (<span style="color: #1e7bda; font-weight: bold;">define</span> (<span style="color: #58b1f3;">read-any</span> p)
   (<span style="color: #1e7bda; font-weight: bold;">let</span> ((result (parser (base-generator-&gt;results (generator p)))))
     (<span style="color: #1e7bda; font-weight: bold;">if</span> (parse-result-successful? result)
         (parse-result-semantic-value result)
         (error 'json-read <span style="color: #e96060;">"JSON Parse Error"</span>
                (<span style="color: #1e7bda; font-weight: bold;">let</span> ((e (parse-result-error result)))
                  (list 'json-parse-error
                        (parse-position-&gt;string (parse-error-position e))
                        (parse-error-expected e)
                        (parse-error-messages e)))))))
#+nend_src
Now we can test our first parser:
#+begin_src scheme
  (read-any (open-string-input-port <span style="color: #e96060;">"    "</span>))
  <span style="color: #319448;">;;</span><span style="color: #319448;">=&gt; #&lt;eof&gt;</span>
</pre>
</div>
</div>
</li></ul>
</div>

<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2">Going Further</h4>
<div class="outline-text-4" id="text-2-3-2">
</div><ul class="org-ul"><li><a id="sec-2-3-2-1" name="sec-2-3-2-1"></a>Parse comments<br  /><div class="outline-text-5" id="text-2-3-2-1">
<p>
Comments are treated as white-spaces, so we can extend white-space parser with comment support.
In json, two kinds of comments are accepted: 
</p>
<ul class="org-ul">
<li>Start with <code>//</code>, end with newline, or
</li>
<li>surrounded by <code>/*</code> and <code>*/</code> pair.
</li>
</ul>
<p>
So the rewritten parser is:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #1e7bda; font-weight: bold;">define</span> <span style="color: #58b1f3;">parser</span>
  (packrat-parser any
                  (any ((white '#\x04) (eof-object)))
                  (white (((? char-whitespace?) white) 'whitespace)
                         ((b &lt;- comment) 'whitespace))
                  (comment (((token <span style="color: #e96060;">"/*"</span>) b &lt;- comment-body) b)
                           (((token <span style="color: #e96060;">"//"</span>) b &lt;- skip-to-newline) b)
                           (() 'whitespace))
                  (comment-body (((token <span style="color: #e96060;">"*/"</span>) w &lt;- white) w)
                               (((? true) comment-body) 'skipped-comment-char))
                  (skip-to-newline (((? (inverse char-newline?))
                                     skip-to-newline) 'whitespace)
                                   (((? char-newline?) white) 'whitespace)
                                   )))
</pre>
</div>
<p>
We can test it:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(read-any (open-string-input-port <span style="color: #e96060;">"  /*comment*/ "</span>))
<span style="color: #319448;">;;</span><span style="color: #319448;">=&gt; #&lt;eof&gt;</span>
(read-any (open-string-input-port <span style="color: #e96060;">"   //comment \n"</span>))
<span style="color: #319448;">;;</span><span style="color: #319448;">=&gt; #&lt;eof&gt;</span>
</pre>
</div>
</div>
</li>
<li><a id="sec-2-3-2-2" name="sec-2-3-2-2"></a>Parse tokens<br  /><div class="outline-text-5" id="text-2-3-2-2">
<p>
There are three basic json token: <code>true</code> <code>false</code> <code>null</code>. Now we deal with these real entities.
</p>
<div class="org-src-container">

<pre class="src src-scheme"><span style="color: #319448;">;; </span><span style="color: #319448;">In json, empty list [] and null are distinct objects, </span>
<span style="color: #319448;">;; </span><span style="color: #319448;">but in scheme (null? '()) =&gt; #t and (list? '()) =&gt; #t, </span>
<span style="color: #319448;">;; </span><span style="color: #319448;">this is the reason why json-null is introduced here.</span>
(<span style="color: #1e7bda; font-weight: bold;">define-record-type</span> json-null)
<span style="color: #319448;">;; </span><span style="color: #319448;">token is defined in packrat-utils module.</span>
(<span style="color: #1e7bda; font-weight: bold;">define</span> (<span style="color: #58b1f3;">token</span> str . comp?)
  (<span style="color: #1e7bda; font-weight: bold;">let</span> ((cmp? (<span style="color: #1e7bda; font-weight: bold;">if</span> (null? comp?)
                  char=?
                  comp?)))
    (<span style="color: #1e7bda; font-weight: bold;">lambda</span> (starting-results)
      (<span style="color: #1e7bda; font-weight: bold;">let</span> <span style="color: #58b1f3;">loop</span> ((pos 0) (results starting-results))
        (<span style="color: #1e7bda; font-weight: bold;">if</span> (= pos (string-length str))
            (make-result str results)
            (<span style="color: #1e7bda; font-weight: bold;">let</span> ((res-token-value (parse-results-token-value results)))
              (<span style="color: #1e7bda; font-weight: bold;">if</span> (<span style="color: #1e7bda; font-weight: bold;">and</span> res-token-value (cmp? res-token-value (string-ref str pos)))
                  (loop (+ pos 1) (parse-results-next results))
                  (make-expected-result (parse-results-position starting-results) str))))))))
(<span style="color: #1e7bda; font-weight: bold;">define</span> <span style="color: #58b1f3;">parser</span>
  (packrat-parser any
                  (any
                   ((white (token <span style="color: #e96060;">"true"</span>)) #t)
                   ((white (token <span style="color: #e96060;">"false"</span>)) #f)
                   ((white (token <span style="color: #e96060;">"null"</span>)) (make-json-null))
                   ((white '#\x04) (eof-object)))
                  (white (((? char-whitespace?) white) 'whitespace)
                         ((b &lt;- comment) 'whitespace))
                  (comment (((token <span style="color: #e96060;">"/*"</span>) b &lt;- comment-body) b)
                           (((token <span style="color: #e96060;">"//"</span>) b &lt;- skip-to-newline) b)
                           (() 'whitespace))
                  (comment-body (((token <span style="color: #e96060;">"*/"</span>) w &lt;- white) w)
                               (((? true) comment-body) 'skipped-comment-char))
                  (skip-to-newline (((? (inverse char-newline?))
                                     skip-to-newline) 'whitespace)
                                   (((? char-newline?) white) 'whitespace)
                                   )))
</pre>
</div>
<p>
We can test these tokens:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(read-any (open-string-input-port <span style="color: #e96060;">"  /*comment*/ true"</span>))
<span style="color: #319448;">;;</span><span style="color: #319448;">=&gt; #t</span>
(read-any (open-string-input-port <span style="color: #e96060;">"   //comment \n false"</span>))
<span style="color: #319448;">;;</span><span style="color: #319448;">=&gt; #f</span>
(read-any (open-string-input-port <span style="color: #e96060;">"   //comment \n null   "</span>))
<span style="color: #319448;">;;</span><span style="color: #319448;">=&gt; #&lt;r6rs:record:json-null&gt;</span>
</pre>
</div>
</div>
</li>
<li><a id="sec-2-3-2-3" name="sec-2-3-2-3"></a>Recursive structure: List<br  /><div class="outline-text-5" id="text-2-3-2-3">
<p>
Lists are such a struct which contains valid json structures.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">syntax</td>
</tr>

<tr>
<td class="left">any</td>
<td class="left">=</td>
<td class="left">list</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">token(true,false,null)</td>
</tr>

<tr>
<td class="left">List</td>
<td class="left">=</td>
<td class="left">[]</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">[any]</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">[any,+]</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>white-spaces are ignored here
</li>
</ul>

<div class="org-src-container">

<pre class="src src-scheme">(<span style="color: #1e7bda; font-weight: bold;">define</span> <span style="color: #58b1f3;">parser</span>
  (packrat-parser any
                  (any
                   ((white '#\[ entries &lt;- array-entries white '#\]) entries)
                   <span style="color: #319448;">;; </span><span style="color: #319448;">list: [ json, json+ ] | []</span>
                   ((white (token <span style="color: #e96060;">"true"</span>)) #t)
                   ((white (token <span style="color: #e96060;">"false"</span>)) #f)
                   ((white (token <span style="color: #e96060;">"null"</span>)) (make-json-null))
                   ((white '#\x04) (eof-object)))
                  (white (((? char-whitespace?) white) 'whitespace)
                         ((b &lt;- comment) 'whitespace))
                  (comment (((token <span style="color: #e96060;">"/*"</span>) b &lt;- comment-body) b)
                           (((token <span style="color: #e96060;">"//"</span>) b &lt;- skip-to-newline) b)
                           (() 'whitespace))
                  (comment-body (((token <span style="color: #e96060;">"*/"</span>) w &lt;- white) w)
                               (((? true) comment-body) 'skipped-comment-char))
                  (skip-to-newline (((? (inverse char-newline?))
                                     skip-to-newline) 'whitespace)
                                   (((? char-newline?) white) 'whitespace))
                  (array-entries ((a &lt;- array-entries-nonempty) a)
                                 (() '()))
                  (array-entries-nonempty ((entry &lt;- any white '#\, entries &lt;- array-entries-nonempty) (cons entry entries))
                                          ((entry &lt;- any) (list entry)))

                  ))x
</pre>
</div>
<p>
Tests:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(read-any (open-string-input-port <span style="color: #e96060;">"  /*comment*/ [true, false, null]"</span>))
<span style="color: #319448;">;;</span><span style="color: #319448;">=&gt; (#t #f #&lt;r6rs:record:json-null&gt;)</span>
(read-any (open-string-input-port <span style="color: #e96060;">"  /*comment*/ [true, [false, false, true], null]"</span>))
<span style="color: #319448;">;;</span><span style="color: #319448;">=&gt; (#t (#f #f #t) #&lt;r6rs:record:json-null&gt;)</span>
</pre>
</div>
</div>
</li></ul>
</div>

<div id="outline-container-sec-2-3-3" class="outline-4">
<h4 id="sec-2-3-3">Complete the job and going further</h4>
<div class="outline-text-4" id="text-2-3-3">
<p>
To complete this json parser, objects, strings and numbers are also needed to be processed, these jobs can be easily done by extending the parser above.
The complete json-parser can be found in my github repository, it is origined from the json-parser in Tony Garnock-Jones' blog, but I have rewritten some parts of it using my packrat extension and utils lib.
The parser can be extended to parse ruby serialized objects(similar to json).
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">Conclusion</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Packrat is a powerful parser and in this blog, I briefed its structure and usage by constructing a json parser.
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
<a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">https://en.wikipedia.org/wiki/Parsing_expression_grammar</a>
</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
<a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar#Advantages">https://en.wikipedia.org/wiki/Parsing_expression_grammar#Advantages</a>
</p></div>

<div class="footdef"><sup><a id="fn.3" name="fn.3" class="footnum" href="#fnr.3">3</a></sup> <p class="footpara">
<a href="https://wiki.call-cc.org/eggref/4/packrat">https://wiki.call-cc.org/eggref/4/packrat</a>
</p></div>

<div class="footdef"><sup><a id="fn.4" name="fn.4" class="footnum" href="#fnr.4">4</a></sup> <p class="footpara">
<a href="https://github.com/petercrlane/r7rs-libs.git">https://github.com/petercrlane/r7rs-libs.git</a>
</p></div>


</div>
</div><div class="post-date">17 Sep 2017</div><h1 class="post-title"><a href="http://chaoseternal.net/hello-world.html">My new blog</a></h1>
<p>
After keeping silence for many years, I am starting a new blog, 
</p>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Hello, twisted spacetime</h2>
<div class="outline-text-2" id="text-1">
<p>
This is my new blog system, which is still under construction.
In this space, I will talk about Scheme, Linux, and other related topics, these will record my adventure into Schemer's land.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Build of this site</h2>
<div class="outline-text-2" id="text-2">
<p>
For integrating these things, these tools are used:
</p>
<ul class="org-ul">
<li>emacs
</li>
<li>org-mode
</li>
<li>org-static-blog
</li>
<li>language-tool
</li>
<li>emacs langtool
</li>
<li>git
</li>
</ul>
<p>
and more.
</p>
</div>
</div>
<div id="archive">
  <a href="archive.html">Older posts</a>
</div>
</div>
</body>
