<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"https://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="https://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<link rel="alternate"
      type="appliation/rss+xml"
      href="http://chaoseternal.net/rss.xml"
      title="RSS feed for http://chaoseternal.net/">
<title>Chaos Eternal</title><meta  name="author" content="Jun Sheng" />
<link href="http://fonts.googleapis.com/css?family=Roboto&subset=latin" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet" type="text/css">
<link href="static/style.css" rel="stylesheet" type="text/css" />
<link rel="icon" href="static/favicon.ico">
<link rel="apple-touch-icon-precomposed" href="static/favicon-152.png">
<link rel="msapplication-TitleImage" href="static/favicon-144.png">
<link rel="msapplication-TitleColor" href="#0141ff">
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"> </script>
<meta http-equiv="content-type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1">
</head>
<body>
<div id="preamble" class="status"><div id="preamble" class="status"><div class="header">
  <a href="http://chaoseternal.net">Chaos Eternal</a>
  <div class="sitelinks">
    <a href="https://twitter.com/chaoseternal">Twitter</a> | <a href="http://github.com/Chaoseternal">Github</a>
  </div>
</div></div>
<div id="content"><div class="post-date">20 Mar 2018</div><h1 class="post-title"><a href="http://chaoseternal.net/a-log-of-trouble-shooting.html">A Log of Network Trouble Shooting</a></h1>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">The problem</h2>
<div class="outline-text-2" id="text-1">
<p>
This story happend in real world, but the customer name is faked.
</p>

<p>
One of my customers, The Big Customer(in abbrev, TBC), is running our product.
</p>

<p>
One day they come to me describe the following wierd phenomeon:
</p>

<p>
They observed a lot of ip packets send from containers in one component of our product, which is a virutal machine of a cluster, 
to other servers without doing SNAT(MASQUERADE), 
the receiving server is not a member of the cluster. As a result, these packets are then getting bounced into TBC’s core network, and triggering alerts.
</p>

<p>
These containers are hosting user applications, these containers are using internal ip addresses (usually 10.254.x.x). 
When processes inside these containers are going to connect outside servers, the packets need to be SNATed by the hosting virtual machine,
this is done by a MASQUERADE rule in iptables’ “nat” table. 
</p>

<p>
On the problematic system, a lot of packets with TCP flag FIN set get send out from container with source ip unchanged, the MASQUERADE rule does not take effect.
When these packets reach the server, they will be considered invalid packets due to source address unrecognized, 
hence RST packets are emitted towards those source addresses, in this case, the 10.254.x.x addresses, 
and these packets get routed into TBC’s core network and trigger alerts.
</p>

<p>
As stated by TBC’s administrator of their core networking, they have been receiving these weird alerts for a long time, 
and only recently can they traced down the origin of these packets, which is send by virtual machines of our product.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Analysis</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Checking connection status</h3>
<div class="outline-text-3" id="text-2-1">
<p>
In container, lots of tcp-connections are in CLOSE-WAIT state.
</p>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Packet analysis using tcpdump</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Packet analysis using tcpdump on the virtual machine:
12 conversations analyzed , three of them are partially captured, 5 conversations are erroneous.  The summary:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">SourceIP/Port</td>
<td class="left">DestIP/Port</td>
<td class="left">Connection status</td>
<td class="left">Remark</td>
</tr>

<tr>
<td class="left">10.254.0.54.38758</td>
<td class="left">xxx.xxx.yyy.yyy.8088</td>
<td class="left">Partially Captured</td>
<td class="left">SYN packet not seen</td>
</tr>

<tr>
<td class="left">xxx.xxx.xxx.xxx.39474</td>
<td class="left">xxx.xxx.yyy.yyy.8088</td>
<td class="left">Partially Captured, erroneous</td>
<td class="left">SYN Packet not seen. FIN packet from client not masqueraded</td>
</tr>

<tr>
<td class="left">xxx.xxx.xxx.xxx.40162</td>
<td class="left">xxx.xxx.yyy.yyy.8088</td>
<td class="left">No error</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">xxx.xxx.xxx.xxx.40888</td>
<td class="left">xxx.xxx.yyy.yyy.8088</td>
<td class="left">No error</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">xxx.xxx.xxx.xxx.41740</td>
<td class="left">xxx.xxx.yyy.yyy.8088</td>
<td class="left">Erroneous</td>
<td class="left">FIN packet from client not masqueraded</td>
</tr>

<tr>
<td class="left">xxx.xxx.xxx.xxx.42478</td>
<td class="left">xxx.xxx.yyy.yyy.8088</td>
<td class="left">Erroneous</td>
<td class="left">FIN packet from client not masqueraded</td>
</tr>

<tr>
<td class="left">xxx.xxx.xxx.xxx.43218</td>
<td class="left">xxx.xxx.yyy.yyy.8088</td>
<td class="left">No error</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">xxx.xxx.xxx.xxx.43994</td>
<td class="left">xxx.xxx.yyy.yyy.8088</td>
<td class="left">No error</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">xxx.xxx.xxx.xxx.44710</td>
<td class="left">xxx.xxx.yyy.yyy.8088</td>
<td class="left">Erroneous</td>
<td class="left">FIN packet from client not masqueraded</td>
</tr>

<tr>
<td class="left">xxx.xxx.xxx.xxx.45426</td>
<td class="left">xxx.xxx.yyy.yyy.8088</td>
<td class="left">Erroneous</td>
<td class="left">FIN packet from client not masqueraded</td>
</tr>

<tr>
<td class="left">xxx.xxx.xxx.xxx.46244</td>
<td class="left">xxx.xxx.yyy.yyy.8088</td>
<td class="left">No error</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">xxx.xxx.xxx.xxx.46964</td>
<td class="left">xxx.xxx.yyy.yyy.8088</td>
<td class="left">Partially Captured</td>
<td class="left">FIN Packet not seen from both side.</td>
</tr>
</tbody>
</table>

<p>
Inspecting a typical erroneous conversation:
</p>
<pre class="example">
15:00:25.416697 IP xxx.xxx.xxx.xxx.41740 &gt; xxx.xxx.yyy.yyy.8088: Flags [S], seq 3714847479, win 28280, options [mss 1414,sackOK,TS val 2156888755 ecr 0,nop,wscale 7], length 0
15:00:25.416995 IP xxx.xxx.yyy.yyy.8088 &gt; xxx.xxx.xxx.xxx.41740: Flags [S.], seq 4230280871, ack 3714847480, win 28960, options [mss 1460,sackOK,TS val 823948244 ecr 2156888755,nop,wscale 7], length 0
15:00:25.417080 IP xxx.xxx.xxx.xxx.41740 &gt; xxx.xxx.yyy.yyy.8088: Flags [.], ack 4230280872, win 221, options [nop,nop,TS val 2156888755 ecr 823948244], length 0
15:00:25.417555 IP xxx.xxx.xxx.xxx.41740 &gt; xxx.xxx.yyy.yyy.8088: Flags [P.], seq 3714847480:3714848324, ack 4230280872, win 221, options [nop,nop,TS val 2156888755 ecr 823948244], length 844
15:00:25.417805 IP xxx.xxx.yyy.yyy.8088 &gt; xxx.xxx.xxx.xxx.41740: Flags [.], ack 3714848324, win 240, options [nop,nop,TS val 823948245 ecr 2156888755], length 0
15:00:25.420292 IP xxx.xxx.yyy.yyy.8088 &gt; xxx.xxx.xxx.xxx.41740: Flags [P.], seq 4230280872:4230281169, ack 3714848324, win 240, options [nop,nop,TS val 823948245 ecr 2156888755], length 297
15:00:25.420596 IP xxx.xxx.xxx.xxx.41740 &gt; xxx.xxx.yyy.yyy.8088: Flags [.], ack 4230281169, win 230, options [nop,nop,TS val 2156888756 ecr 823948245], length 0
15:00:46.760856 IP xxx.xxx.yyy.yyy.8088 &gt; xxx.xxx.xxx.xxx.41740: Flags [F.], seq 4230281169, ack 3714848324, win 240, options [nop,nop,TS val 823953579 ecr 2156888756], length 0

15:00:46.800503 IP xxx.xxx.xxx.xxx.41740 &gt; xxx.xxx.yyy.yyy.8088: Flags [.], ack 4230281170, win 230, options [nop,nop,TS val 2156894101 ecr 823953579], length 0
~~~~~~~~~~~~~~~
15:03:21.948707 IP 10.254.0.54.41740 &gt; xxx.xxx.yyy.yyy.8088: Flags [F.], seq 3714848324, ack 4230281170, win 230, options [nop,nop,TS val 2156932888 ecr 823953579], length 0
~~~~~~~~~~~~~~~
15:03:22.152480 IP 10.254.0.54.41740 &gt; xxx.xxx.yyy.yyy.8088: Flags [F.], seq 3714848324, ack 4230281170, win 230, options [nop,nop,TS val 2156932939 ecr 823953579], length 0
15:03:22.356643 IP 10.254.0.54.41740 &gt; xxx.xxx.yyy.yyy.8088: Flags [F.], seq 3714848324, ack 4230281170, win 230, options [nop,nop,TS val 2156932990 ecr 823953579], length 0
15:03:22.764540 IP 10.254.0.54.41740 &gt; xxx.xxx.yyy.yyy.8088: Flags [F.], seq 3714848324, ack 4230281170, win 230, options [nop,nop,TS val 2156933092 ecr 823953579], length 0
15:03:23.583041 IP 10.254.0.54.41740 &gt; xxx.xxx.yyy.yyy.8088: Flags [F.], seq 3714848324, ack 4230281170, win 230, options [nop,nop,TS val 2156933296 ecr 823953579], length 0
15:03:25.216453 IP 10.254.0.54.41740 &gt; xxx.xxx.yyy.yyy.8088: Flags [F.], seq 3714848324, ack 4230281170, win 230, options [nop,nop,TS val 2156933705 ecr 823953579], length 0
15:03:28.492444 IP 10.254.0.54.41740 &gt; xxx.xxx.yyy.yyy.8088: Flags [F.], seq 3714848324, ack 4230281170, win 230, options [nop,nop,TS val 2156934524 ecr 823953579], length 0
15:03:35.036477 IP 10.254.0.54.41740 &gt; xxx.xxx.yyy.yyy.8088: Flags [F.], seq 3714848324, ack 4230281170, win 230, options [nop,nop,TS val 2156936160 ecr 823953579], length 0
15:03:48.124523 IP 10.254.0.54.41740 &gt; xxx.xxx.yyy.yyy.8088: Flags [F.], seq 3714848324, ack 4230281170, win 230, options [nop,nop,TS val 2156939432 ecr 823953579], length 0
15:04:14.332468 IP 10.254.0.54.41740 &gt; xxx.xxx.yyy.yyy.8088: Flags [F.], seq 3714848324, ack 4230281170, win 230, options [nop,nop,TS val 2156945984 ecr 823953579], length 0
</pre>
<p>
The evidence that all these packets are belong to the same conversation is the fact that all sequence numbers are continuous. 
The marked two lines show that the FIN packet from client side is sent more than 2 minutes later
 than the client side ACKs the FIN packet sent from server side. 
This is the nf_conntrack_tcp_timeout_close_wait settings on the virtual machine:
this timeout is set to 60 second.
</p>

<p>
When conntrack module of the virtual machine see both server side FIN packet(SEQ 4230281169) and client’s ACK packet to the FIN (ACK 4230281170), 
it will mark the connect as CLOSE_WAIT state, the entry describing the connection will be deleted after 60 seconds(nf_conntrack_tcp_timeout_close_wait).
At the moment the client side sends out a FIN packet after almost 2 minutes (SEQ 3714848324), 
the packet does not match any conntrack entry, and will be marked as an INVALID packet. 
SNAT(MASQUERAD in this case) rule of iptables depends on conntrack to remember each connection’s state, 
then INVALID packets will not be masqueraded, such packet will just be simply routed to its destination. 
When the server side receives these un-masqueraded packets, 
it does not have any information about the src address of the packets and then bounces these packet to their src address with RST flag. 
Client will not receive any response of the FIN packets, and retries until another timeout occurs. 
</p>

<p>
Under such scenario, each of FIN packet resent by client will cause a bounced packet.
</p>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Analyze the code</h3>
<div class="outline-text-3" id="text-2-3">
<p>
The server xxx.xxx.yyy.yyy.8088 is a zabbix server gathering metrics from container. 
There is an agent program resides in each application container which sends metrics data every defined period. 
The data send is done by doing an HTTP POST request to zabbix server. 
After analyzing the code of this agent, it is found that the agent program does not explicitly release http response objects, 
which will leave the socket file open or half-open in this case. Until these objects are collected by GC of jvm, these socket files will not be closed. 
</p>

<p>
Such behavior will definitely introduce a interval between server side close and client side close, 
this interval is the already shown interval between client ACK of Server FIN and client FIN packet. and this is the root cause of this issue.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Conclusion and suggestion</h2>
<div class="outline-text-2" id="text-3">
<p>
The implicit release of response object is the root cause of this issue,
 this behavior will introduce an interval between service side close and client side close. 
This interval is longer than the virtual machine’s nf_conntrack_tcp_timeout_close_wait, 
and the conntrack entry will be discarded before client sends out FIN packet, hence this FIN packet will be marked as invalid and won’t be masqueraded.
Suggestions on mitigating this problems are:
</p>
<ul class="org-ul">
<li>improve code  quality, avoid such implicit release of resources
</li>
<li>or an iptables rule like  
<code>iptable -A FORWARD -j DROP -m conntrack --ctstate INVALID</code>
to drop each invalid packets.
</li>
</ul>
</div>
</div>
<div class="post-date">29 Oct 2017</div><h1 class="post-title"><a href="http://chaoseternal.netpackrat-intro.html">Packrat parser in R6RS</a></h1>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Packrat algorithm</h2>
<div class="outline-text-2" id="text-1">
<p>
Packrat parsing algorithm is an algorithm for parsing PEG<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>, it can parse PEG in guaranteed linear time.<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup>
There are lots of resources about PEG and packrat algorithm here: <a href="http://bford.info/packrat/">http://bford.info/packrat/</a>.
<a href="https://tech.labs.oliverwyman.com/author/tonyg/">Tony Garnock-Jones</a> had an implementation of packrat in his <a href="http://tech.labs.oliverwyman.com/blog/2005/08/11/extensible-parsing-systems/">blog</a>, and he then <a href="https://tech.labs.oliverwyman.com/blog/2005/08/22/json-for-mzscheme-and-a-portable-packrat-parsing-combinator-library/">rewrote</a> it using MzScheme and then upon the parser he wrote a JSON read-write library. 
He also wrote a <a href="http://tech.labs.oliverwyman.com/downloads/dev.lshift.net/tonyg/packrat.pdf">document</a> about how to use it.
This packrat library is included in Chicken Scheme's egg system<sup><a id="fnr.3" name="fnr.3" class="footref" href="#fn.3">3</a></sup> and then be ported as a R7RS library<sup><a id="fnr.4" name="fnr.4" class="footref" href="#fn.4">4</a></sup>. 
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">A brief walk through of packrat</h2>
<div class="outline-text-2" id="text-2">
<p>
PEG is very similar to regexp. Here is the comparison of concepts between PEG and regexp
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">&#xa0;</td>
<td class="left">PEG</td>
<td class="left">Regexp</td>
</tr>

<tr>
<td class="left">atoms</td>
<td class="left">any non-terminal symbol</td>
<td class="left">any character</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">terminal symbol</td>
<td class="left">$, \&gt;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">empty</td>
<td class="left">empty</td>
</tr>

<tr>
<td class="left">combination operators</td>
<td class="left">sequence</td>
<td class="left">string</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">ordered choice</td>
<td class="left">a &vert; b</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">zero-or-more</td>
<td class="left">a*</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">one-or-more</td>
<td class="left">a+</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">optional</td>
<td class="left">a?</td>
</tr>
</tbody>
</table>

<p>
Generally PEG is more powerful than regular expressions, for example, PEG can handle nested parenthesis while regexp can't, this is because PEG is recursive. 
For example, regular expressions can't process JSON data with arbitrary depth.
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">My Packrat extensions</h3>
<div class="outline-text-3" id="text-2-1">
<p>
I have written some extensions to original packrat library, these extensions is intended to make life easier with packrat. 
The code can be find here: <a href="https://github.com/ChaosEternal/packrat-extended"><a href="https://github.com/ChaosEternal/packrat-extended">https://github.com/ChaosEternal/packrat-extended</a></a>, tested under ChezScheme.
First, I add a <code>(? pred)</code> syntax, a place for a user defined predictors (in packrat.ss),
then I add some help functions like character test functions and logic combination functions (in packrat-utils.ss), some of them(token, json-string) are isolated from the json parser.
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Using Packrat</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Macro  <code>packrat-parser</code> provides syntactic sugar to build complex parser combinator from simpler ones. 
Input of these combinators are generators which are producing pairs of <code>(kind value)</code>, and parser will check with the kind and take the value.
Although the generator in the example specified in Tony's document generates ~'(kind value)~ where kind is symbol and value is numeric value, <code>(char char)</code> will be generated in most use case.
</p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Parse json step by step</h3>
<div class="outline-text-3" id="text-2-3">
</div><div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1">Very beginning</h4>
<div class="outline-text-4" id="text-2-3-1">
</div><ul class="org-ul"><li><a id="sec-2-3-1-1" name="sec-2-3-1-1"></a>Generator<br  /><div class="outline-text-5" id="text-2-3-1-1">
<p>
This generator read from a given port and produces a stream of (char . char).
</p>
<div class="org-src-container">

<pre class="src src-scheme">(import (ext packrat)
	(ext packrat-utils)
	(rnrs (6))
	)

(define (generator p)
  (let ((ateof #f)
	(pos (top-parse-position "&lt;?&gt;")))
    (lambda ()
      (if ateof
	  (values pos #f)
	  (let ((x (read-char p)))
	    (if (eof-object? x)
		(begin
		  (set! ateof #t)
		  (values pos (cons #\x04 #\x04)))
		(let ((old-pos pos))
		  (set! pos (update-parse-position pos x))
		  (values old-pos (cons x x)))))))))
</pre>
</div>
</div>
</li>
<li><a id="sec-2-3-1-2" name="sec-2-3-1-2"></a>Parser for Whitespace<br  /><div class="outline-text-5" id="text-2-3-1-2">
<p>
We can start from a very simple parser which just reads arbitary number of white-spaces.
The parse returns nothing but an <code>eof-object</code> when parse reaches the end of file.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">syntax</td>
</tr>

<tr>
<td class="left">any</td>
<td class="left">=</td>
<td class="left">white eof</td>
</tr>

<tr>
<td class="left">white</td>
<td class="left">=</td>
<td class="left">ws*</td>
</tr>
</tbody>
</table>

<div class="org-src-container">

<pre class="src src-scheme">(define parser
  (packrat-parser any
		  (any ((white '#\x04) (eof-object)))
		  (white (((? char-whitespace?) white) 'whitespace)
			 (() 'whitespace))))
</pre>
</div>
</div>
</li>

<li><a id="sec-2-3-1-3" name="sec-2-3-1-3"></a>A reader function<br  /><div class="outline-text-5" id="text-2-3-1-3">
<p>
A reader function integrates parser and generator.
</p>
<div class="org-src-container">

<pre class="src src-scheme">  (define (read-any p)
   (let ((result (parser (base-generator-&gt;results (generator p)))))
     (if (parse-result-successful? result)
	 (parse-result-semantic-value result)
	 (error 'json-read "JSON Parse Error"
		(let ((e (parse-result-error result)))
		  (list 'json-parse-error
			(parse-position-&gt;string (parse-error-position e))
			(parse-error-expected e)
			(parse-error-messages e)))))))
#+nend_src
Now we can test our first parser:
#+begin_src scheme
  (read-any (open-string-input-port "    "))
  ;;=&gt; #&lt;eof&gt;
</pre>
</div>
</div>
</li></ul>
</div>

<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2">Going Further</h4>
<div class="outline-text-4" id="text-2-3-2">
</div><ul class="org-ul"><li><a id="sec-2-3-2-1" name="sec-2-3-2-1"></a>Parse comments<br  /><div class="outline-text-5" id="text-2-3-2-1">
<p>
Comments are treated as white-spaces, so we can extend white-space parser with comment support.
In json, two kinds of comments are accepted: 
</p>
<ul class="org-ul">
<li>Start with <code>//</code>, end with newline, or
</li>
<li>surrounded by <code>/*</code> and <code>*/</code> pair.
</li>
</ul>
<p>
So the rewritten parser is:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define parser
  (packrat-parser any
		  (any ((white '#\x04) (eof-object)))
		  (white (((? char-whitespace?) white) 'whitespace)
			 ((b &lt;- comment) 'whitespace))
		  (comment (((token "/*") b &lt;- comment-body) b)
			   (((token "//") b &lt;- skip-to-newline) b)
			   (() 'whitespace))
		  (comment-body (((token "*/") w &lt;- white) w)
			       (((? true) comment-body) 'skipped-comment-char))
		  (skip-to-newline (((? (inverse char-newline?))
				     skip-to-newline) 'whitespace)
				   (((? char-newline?) white) 'whitespace)
				   )))
</pre>
</div>
<p>
We can test it:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(read-any (open-string-input-port "  /*comment*/ "))
;;=&gt; #&lt;eof&gt;
(read-any (open-string-input-port "   //comment \n"))
;;=&gt; #&lt;eof&gt;
</pre>
</div>
</div>
</li>
<li><a id="sec-2-3-2-2" name="sec-2-3-2-2"></a>Parse tokens<br  /><div class="outline-text-5" id="text-2-3-2-2">
<p>
There are three basic json token: <code>true</code> <code>false</code> <code>null</code>. Now we deal with these real entities.
</p>
<div class="org-src-container">

<pre class="src src-scheme">;; In json, empty list [] and null are distinct objects, 
;; but in scheme (null? '()) =&gt; #t and (list? '()) =&gt; #t, 
;; this is the reason why json-null is introduced here.
(define-record-type json-null)
;; token is defined in packrat-utils module.
(define (token str . comp?)
  (let ((cmp? (if (null? comp?)
		  char=?
		  comp?)))
    (lambda (starting-results)
      (let loop ((pos 0) (results starting-results))
	(if (= pos (string-length str))
	    (make-result str results)
	    (let ((res-token-value (parse-results-token-value results)))
	      (if (and res-token-value (cmp? res-token-value (string-ref str pos)))
		  (loop (+ pos 1) (parse-results-next results))
		  (make-expected-result (parse-results-position starting-results) str))))))))
(define parser
  (packrat-parser any
		  (any
		   ((white (token "true")) #t)
		   ((white (token "false")) #f)
		   ((white (token "null")) (make-json-null))
		   ((white '#\x04) (eof-object)))
		  (white (((? char-whitespace?) white) 'whitespace)
			 ((b &lt;- comment) 'whitespace))
		  (comment (((token "/*") b &lt;- comment-body) b)
			   (((token "//") b &lt;- skip-to-newline) b)
			   (() 'whitespace))
		  (comment-body (((token "*/") w &lt;- white) w)
			       (((? true) comment-body) 'skipped-comment-char))
		  (skip-to-newline (((? (inverse char-newline?))
				     skip-to-newline) 'whitespace)
				   (((? char-newline?) white) 'whitespace)
				   )))
</pre>
</div>
<p>
We can test these tokens:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(read-any (open-string-input-port "  /*comment*/ true"))
;;=&gt; #t
(read-any (open-string-input-port "   //comment \n false"))
;;=&gt; #f
(read-any (open-string-input-port "   //comment \n null   "))
;;=&gt; #&lt;r6rs:record:json-null&gt;
</pre>
</div>
</div>
</li>
<li><a id="sec-2-3-2-3" name="sec-2-3-2-3"></a>Recursive structure: List<br  /><div class="outline-text-5" id="text-2-3-2-3">
<p>
Lists are such a struct which contains valid json structures.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">syntax</td>
</tr>

<tr>
<td class="left">any</td>
<td class="left">=</td>
<td class="left">list</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">token(true,false,null)</td>
</tr>

<tr>
<td class="left">List</td>
<td class="left">=</td>
<td class="left">[]</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">[any]</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">[any,+]</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>white-spaces are ignored here
</li>
</ul>

<div class="org-src-container">

<pre class="src src-scheme">(define parser
  (packrat-parser any
		  (any
		   ((white '#\[ entries &lt;- array-entries white '#\]) entries)
		   ;; list: [ json, json+ ] | []
		   ((white (token "true")) #t)
		   ((white (token "false")) #f)
		   ((white (token "null")) (make-json-null))
		   ((white '#\x04) (eof-object)))
		  (white (((? char-whitespace?) white) 'whitespace)
			 ((b &lt;- comment) 'whitespace))
		  (comment (((token "/*") b &lt;- comment-body) b)
			   (((token "//") b &lt;- skip-to-newline) b)
			   (() 'whitespace))
		  (comment-body (((token "*/") w &lt;- white) w)
			       (((? true) comment-body) 'skipped-comment-char))
		  (skip-to-newline (((? (inverse char-newline?))
				     skip-to-newline) 'whitespace)
				   (((? char-newline?) white) 'whitespace))
		  (array-entries ((a &lt;- array-entries-nonempty) a)
				 (() '()))
		  (array-entries-nonempty ((entry &lt;- any white '#\, entries &lt;- array-entries-nonempty) (cons entry entries))
					  ((entry &lt;- any) (list entry)))

		  ))x
</pre>
</div>
<p>
Tests:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(read-any (open-string-input-port "  /*comment*/ [true, false, null]"))
;;=&gt; (#t #f #&lt;r6rs:record:json-null&gt;)
(read-any (open-string-input-port "  /*comment*/ [true, [false, false, true], null]"))
;;=&gt; (#t (#f #f #t) #&lt;r6rs:record:json-null&gt;)
</pre>
</div>
</div>
</li></ul>
</div>

<div id="outline-container-sec-2-3-3" class="outline-4">
<h4 id="sec-2-3-3">Complete the job and going further</h4>
<div class="outline-text-4" id="text-2-3-3">
<p>
To complete this json parser, objects, strings and numbers are also needed to be processed, these jobs can be easily done by extending the parser above.
The complete json-parser can be found in my github repository, it is origined from the json-parser in Tony Garnock-Jones' blog, but I have rewritten some parts of it using my packrat extension and utils lib.
The parser can be extended to parse ruby serialized objects(similar to json).
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">Conclusion</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Packrat is a powerful parser and in this blog, I briefed its structure and usage by constructing a json parser.
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
<a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">https://en.wikipedia.org/wiki/Parsing_expression_grammar</a>
</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
<a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar#Advantages">https://en.wikipedia.org/wiki/Parsing_expression_grammar#Advantages</a>
</p></div>

<div class="footdef"><sup><a id="fn.3" name="fn.3" class="footnum" href="#fnr.3">3</a></sup> <p class="footpara">
<a href="https://wiki.call-cc.org/eggref/4/packrat">https://wiki.call-cc.org/eggref/4/packrat</a>
</p></div>

<div class="footdef"><sup><a id="fn.4" name="fn.4" class="footnum" href="#fnr.4">4</a></sup> <p class="footpara">
<a href="https://github.com/petercrlane/r7rs-libs.git">https://github.com/petercrlane/r7rs-libs.git</a>
</p></div>


</div>
</div><div class="post-date">29 Oct 2017</div><h1 class="post-title"><a href="http://chaoseternal.netsyntax-scheme.html">Scheme Syntax-Case usage</a></h1>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Macros of The Scheme Programming Language</h2>
<div class="outline-text-2" id="text-1">
<p>
Scheme has a powerful macro system, in most scheme implementation, only very limited primitive forms
are implemented and others are derived by using macros. For example, r5rs standard defines 23 syntactic constructs, 11 of them can be defined using other more fundamental ones. <sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>
</p>

<p>
There are many macro systems exist in Scheme's world, <code>define-macro</code>, <code>syntax-rules</code>, <code>syntax-case</code> are commonly adopted.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">The <code>define-macro</code> system</h2>
<div class="outline-text-2" id="text-2">
<p>
  <code>define-macro</code> AKA <code>defmacro</code> is the traditional way of defining macro in lisp world. Macros defined by <code>define-macro</code> are roughly procedures transform(expand) input form to another s-expression, 
the transformation itself usually be called "applying the macro". Generally speaking, the body of <code>define-macro</code> can be any expression which returns a valid scheme expression on evaluation, 
and the arguments of <code>define-macro</code> are also the arguments of the expression(if seen as body of a lambda).
</p>

<p>
For example, this macro:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define-macro (when cond exp . rest)
  `(if ,cond
       (begin ,exp . ,rest)))
</pre>
</div>
<p>
will define a macro named <code>when</code>.
And on applying this macro, such form <code>(when (&gt; n 0) exp1 exp2)</code> will be transformed (expanded) as:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(if (&gt; n 0)
    (begin exp1 
	   exp2))
</pre>
</div>
<p>
This transformation done by macro <code>when</code> is just filling out a template using parameters of <code>when</code>: <code>(&gt; n 0)</code>, <code>exp1</code> and <code>(exp2)</code>. Or say, the macro generates new codes.
</p>

<p>
Because the nature of macros, code generation, macros are very powerful tools in lisp languages as well as in Scheme.
</p>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Hygienic problem of <code>define-macro</code></h2>
<div class="outline-text-2" id="text-3">
<p>
  The <code>define-macro</code> macro system is so rough that it does not capture binding of any symbols appeared in macro definition, and these symbols' meaning can be changed when the macros applying,
this will make the macros' behavior be very wierd if they are used with careless.
</p>

<p>
Consider the macro <code>when</code> defined in the previous secrtion, in the scenario demostraded here: 
</p>
<div class="org-src-container">

<pre class="src src-scheme">(let ((begin list))
  (when #f 1 2))
</pre>
</div>
<p>
the code will be equivalent of:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(if #t
    (list 1 2))
</pre>
</div>
<p>
This is because the <code>define-macro</code> only defines the form that <code>when</code> will be expanded but not the binding of symbols, these symbols' meaning can be altered in different context.
</p>

<p>
Such problem is called the hygienic problem.
</p>

<p>
Scheme implatations which have <code>define-macro</code> system also provide <code>gensym</code> or similar procedures which can generate symbols on the fly to mimic(partially) the hygienic problem of the <code>define-macro</code> system.
For example, this code defined a naive macro <code>swap!</code> which swaps value of two variables:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define-macro (swap! o1 o2)
  `(let ((tmp ,o1))
     (set! ,o1 ,o2)
     (set! ,o2 tmp)))
</pre>
</div>
<p>
If one uses this marco like <code>(swap! tmp something)</code> or <code>(swap! something tmp)</code>, the symbol <code>tmp</code> will be captured and the result is incorrect.
This macro can be rewritten using <code>gensym</code>:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define-macro (swap1 o1 o2)
  (let ((tmp (gensym)))
    `(let ((,tmp ,o1))
       (set! ,o1 ,o2)
       (set! ,o2 ,tmp))))
</pre>
</div>
<p>
In this version of <code>swap!</code>, the danger of unwanted symbol capture will not exist.
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">The <code>syntax-rules</code> system</h2>
<div class="outline-text-2" id="text-4">
<p>
<code>syntax-rules</code> is a solution to hygienic problems. Since it is adopted in the R5RS, it is wildly implemented in different Scheme implementations.
<code>syntax-rules</code> uses pattern matching to construct macros.
</p>

<p>
With <code>syntax-rules</code>, the macro <code>when</code> can be re-written as:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define-syntax when
  (syntax-rules ()
    ((when cond exp1 ...)
     (if cond
	 (begin exp1 ...)))))
</pre>
</div>

<p>
The syntax of using <code>syntax-rules</code> is <code>(syntax-rules literals (pattern template) ...)</code>, the macro will replace evey matching pattern to the corresponding template.
</p>

<p>
  The major difference between syntax-rules and define-marco is that <code>syntax-rules</code> garentees hygienicness, in fact, all symbols occure in <code>template</code> has definite meaning: if the symbol is matched in pattern, 
the pattern value is captured, else the binding of symbols in the environment is captured. Thus these symbols' meaning remains the same wherever they are used, this is hygienicness of macro.
</p>

<p>
<code>syntax-rules</code> is very useful, but it also has limitations<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup><sup>, </sup><sup><a id="fnr.3" name="fnr.3" class="footref" href="#fn.3">3</a></sup>, it does not provides ways to modify the templates, there exists some cases where it is harder to write with <code>syntax-rules</code> than define-macro.
For more details about <code>syntax-rules</code> system, this article<sup><a id="fnr.4" name="fnr.4" class="footref" href="#fn.4">4</a></sup> is very useful.
</p>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">The <code>syntax-case</code> system</h2>
<div class="outline-text-2" id="text-5">
<p>
The <code>syntax-case</code> system is somehow similar to <code>gensym</code> approach, but it is an extreme. It has the same power as <code>define-macro</code> but retains hygenicness.
Using <code>syntax-case</code>, the macro <code>when</code> can be rewritten as:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define-syntax when
  (lambda (stx)
    (syntax-case stx ()
	((_ cond exp1 . exp2)
	 #'(if cond
	       (begin exp1 . exp2))))))
</pre>
</div>
<p>
  Here, the form <code>#'(if cond (begin exp1 . exp2))</code> is the corresponding part of <code>`(if ,cond (begin ,exp . ,rest))</code> of <code>define-macro</code>, they have similar structure. The difference
here is only that the body of syntax-case should return a syntax object, not a mere list as define-macro returns. But in <code>syntax-case</code>, symbol <code>if</code> and <code>begin</code> was captured the definition of defining environment while <code>cond</code>, <code>exp1</code> and <code>exp2</code> are replaced with applying 
arguments when the macro is applied, since they appear in the pattern form of <code>syntax-case</code>. This is how hygenicness is archieved.
</p>

<p>
The macro <code>swap!</code>:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define-syntax swap!
  (lambda (stx)
    (syntax-case stx ()
      ((_ op1 op2)
       #'(let ((tmp op1))
	   (set! op1 op2)
	   (set! op2 tmp))))))
</pre>
</div>
<p>
The expanded result(using 'expand' of ChezScheme <code>(expand '(swap! var1 var2))</code>):
</p>
<div class="org-src-container">

<pre class="src src-scheme">(let ([#{tmp cvbrbh0gnpwjvy0dl1m1nb-1} var1])
  (set! var1 var2)
  (set! var2 #{tmp cvbrbh0gnpwjvy0dl1m1nb-1}))
</pre>
</div>
<p>
It is shown that hygenicness is automatically done by the same way of <code>gensym</code>.
</p>

<p>
  The 'syntax' objects is a special type objects defined in scheme implementations which has syntax-case system ported. They can be converted to scheme objects on demand, and when returned by syntax-case, 
the macro expansion is done.
</p>

<p>
The following examples shows a more complex usage of syntax-case, upon expansion, the macro will be expanded to n-th fibonacci number:
</p>
<div class="org-src-container">

<pre class="src src-scheme">;; this macro using iterative approach
(define-syntax fib
  (lambda (x)
    (syntax-case x ()
      ((fib n)
       #'(fib n 1 0))
      ((fib 0 num2 num3) (syntax-&gt;datum #'num2))
      ((fib num1 num2 num3)
       (with-syntax ((n (datum-&gt;syntax #'fib
				       (- (syntax-&gt;datum #'num1)
					  1)))
		     (n2 (datum-&gt;syntax #'fib
					(+ (syntax-&gt;datum #'num2)
					   (syntax-&gt;datum #'num3))))
		     (n3 (syntax num2)))
	 #'(fib n n2 n3))))))
;; this macro is recursive and much slower
(define-syntax fib2
  (lambda (x)
    (syntax-case x ()
      ((fib2 0)
       #'1)
      ((fib2 1)
       #'1)
      ((fib2 n)
       (with-syntax ((n2 (datum-&gt;syntax #'fib2
					(- (syntax-&gt;datum #'n) 1)))
		     (n3 (datum-&gt;syntax #'fib2
					(- (syntax-&gt;datum #'n) 2))))
	 #'(+ (fib2 n2) (fib2 n3)))))))
</pre>
</div>

<p>
The <code>syntax-case</code> system is so powerful that even the <code>syntax-rules</code> system is just a derivation of it<sup><a id="fnr.5" name="fnr.5" class="footref" href="#fn.5">5</a></sup>. 
</p>

<p>
In rencent Elixr<sup><a id="fnr.6" name="fnr.6" class="footref" href="#fn.6">6</a></sup> release(1.2), a ~with~<sup><a id="fnr.7" name="fnr.7" class="footref" href="#fn.7">7</a></sup> clause is introduced to provide guarded execution of some code, the same effect can be easily archieved in scheme by using macros:
</p>
<div class="org-src-container">

<pre class="src src-scheme">(define-syntax and-let*-values-check
  (lambda (stx)
    (syntax-case stx (else)
      ((kw (?bind0 ?bind1 ...) ?body0 ... (else ?expr0 ...))
       (syntax-case #'?bind0 ()
	 (((?b0 ?b1 ...) ?exp)
	  (let* ((?check-b0 (car (generate-temporaries (list #'?b0)))))
	    #`(let-values (((#,?check-b0 ?b1 ...) ?exp))
		(if (equal? #,?check-b0 ?b0)
		    (kw (?bind1 ...) ?body0 ...)
		    (begin ?expr0 ...)))))))
      ((_ () ?body0 ... (else ?expr0 ...))
       #'(begin ?body0 ...))
      ((kw (?bind0 ...) ?body0 ...)
       #'(kw (?bind0 ...) ?body0 ... (else #f))))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Conclusions and more</h2>
<div class="outline-text-2" id="text-6">
<p>
  In scheme's world, the word 'syntax' mostly refers to two things, one is the lexical structure of program, which defined by the reader, 
usually they are s-expressions or converted to s-expressions by reader, other one is the context structure of a program, which defines how program is executed.
Due to the powerfulness of s-expressions, the first meaning of syntax is insignificant compare to the second one. And with the macro system, one can easily extend the
 syntax scheme, just as shown in <sup><a id="fnr.5.100" name="fnr.5.100" class="footref" href="#fn.5">5</a></sup>. The lastest example of previous section even shows how to borrow syntax-sugars from other languages. Yes, syntax-sugar, as its name, 
they are not essentials but sugars just make life happier. And even type systems can be defined using macros<sup><a id="fnr.8" name="fnr.8" class="footref" href="#fn.8">8</a></sup>.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
<a href="https://en.wikipedia.org/wiki/Scheme_(programming_language)">https://en.wikipedia.org/wiki/Scheme_(programming_language)</a>#Minimalism
</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
<a href="https://groups.google.com/forum/#!msg/comp.lang.scheme/gKdyiCnf54E/sxo_gYLvWuUJ;context-place=msg/comp.lang.scheme/Alkectj2ge0/N65W9KNd6LcJ">https://groups.google.com/forum/#!msg/comp.lang.scheme/gKdyiCnf54E/sxo_gYLvWuUJ;context-place=msg/comp.lang.scheme/Alkectj2ge0/N65W9KNd6LcJ</a>
</p></div>

<div class="footdef"><sup><a id="fn.3" name="fn.3" class="footnum" href="#fnr.3">3</a></sup> <p class="footpara">
<a href="https://www.gnu.org/software/guile/manual/html_node/Syntax-Rules.html">https://www.gnu.org/software/guile/manual/html_node/Syntax-Rules.html</a>
</p></div>

<div class="footdef"><sup><a id="fn.4" name="fn.4" class="footnum" href="#fnr.4">4</a></sup> <p class="footpara">
<a href="https://hipster.home.xs4all.nl/lib/scheme/gauche/define-syntax-primer.txt">https://hipster.home.xs4all.nl/lib/scheme/gauche/define-syntax-primer.txt</a>
</p></div>

<div class="footdef"><sup><a id="fn.5" name="fn.5" class="footnum" href="#fnr.5">5</a></sup> <p class="footpara">
<a href="http://www.cs.indiana.edu/~dyb/pubs/tr356.pdf">http://www.cs.indiana.edu/~dyb/pubs/tr356.pdf</a>
</p></div>

<div class="footdef"><sup><a id="fn.6" name="fn.6" class="footnum" href="#fnr.6">6</a></sup> <p class="footpara">
<a href="https://elixir-lang.github.io">https://elixir-lang.github.io</a>
</p></div>

<div class="footdef"><sup><a id="fn.7" name="fn.7" class="footnum" href="#fnr.7">7</a></sup> <p class="footpara">
<a href="http://learningelixir.joekain.com/learning-elixir-with/">http://learningelixir.joekain.com/learning-elixir-with/</a>
</p></div>

<div class="footdef"><sup><a id="fn.8" name="fn.8" class="footnum" href="#fnr.8">8</a></sup> <p class="footpara">
<a href="http://www.ccs.neu.edu/home/stchang/popl2017/">http://www.ccs.neu.edu/home/stchang/popl2017/</a>
</p></div>


</div>
</div><div class="post-date">17 Sep 2017</div><h1 class="post-title"><a href="http://chaoseternal.nethello-world.html">My new blog</a></h1>
<p>
After keeping silence for many years, I am starting a new blog, 
</p>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Hello, twisted spacetime</h2>
<div class="outline-text-2" id="text-1">
<p>
This is my new blog system, which is still under construction.
In this space, I will talk about Scheme, Linux, and other related topics, these will record my adventure into Schemer's land.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Build of this site</h2>
<div class="outline-text-2" id="text-2">
<p>
For integrating these things, these tools are used:
</p>
<ul class="org-ul">
<li>emacs
</li>
<li>org-mode
</li>
<li>org-static-blog
</li>
<li>language-tool
</li>
<li>emacs langtool
</li>
<li>git
</li>
</ul>
<p>
and more.
</p>
</div>
</div>
<div id="archive">
  <a href="http://chaoseternal.net/archive.html">Other posts</a>
</div>
</div>
</body>
